(+ 1 1)
(+ 1 1)
(+ 1 1)
(def! x 1)
x
(def! x (fn* [a] (+ a a)))
x
(x 10)
(def! x (fn* (a) (+ a a)))
(def! x (fn* [a] (+ a a)))
(x 1)
(def! x (fn* [a] (+ a a)))
(x 10)
(def! x (fn* [a] (+ a a)))
(def! x (fn* [a] (+ a a)))
(x 10)
(x 10)
(x 10)
(x "asd")
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
(throw "err1)
(throw "err1")
(throw "err1")
(throw "err1")
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
(throw "err1")
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
 (try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (do (try* "t1" (catch* e "c1")) (throw "e1")) (catch* e "c2"))
(try* (try* (throw "e1") (catch* e (throw "e2"))) (catch* e "c2"))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(= () (map str ()))
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(= [] (vector))
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(= () (keys hm1))
(keys hm2)
(keys {"1" 1})
(vals hm1)
(= () (vals hm1))
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(throw {:msg "err2"})
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {} (hash-map))
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(def! bar (fn* [a] {:foo (get a :foo)}))
(bar {:foo (fn* [x] x)})
(bar {:foo 3})
___
(___)
(let* [a 1 b 2] (do (___)))
nil
(nil? 1)
(nil? nil)
sum
map
reduce
fold
(atom 1)
(1)
[1]
(map [1 2 3] (fn
(def! add2 (fn* [a] (+ a 2)))
(map [ 1 2 3] add2)
(map [] [1 2] add2)
add2
(add2 2)
(map add2 [1 2 3])
